"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorPkg = exports.ValidatorDev = void 0;
const node_path_1 = require("node:path");
const node_fs_1 = require("node:fs");
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const validator_1 = require("@tableland/validator");
const shelljs_1 = __importDefault(require("shelljs"));
const util_js_1 = require("./util.js");
// NOTE: We are creating this file in the fixup.sh script so that we can support cjs and esm
const get_dirname_js_1 = require("./get-dirname.js");
const _dirname = (0, get_dirname_js_1.getDirname)();
const spawnSync = cross_spawn_1.default.sync;
// TODO: should this be a per instance value?
// store the Validator config file in memory, so we can restore it during cleanup
let ORIGINAL_VALIDATOR_CONFIG;
class ValidatorPkg {
    constructor(validatorDir, registryPort) {
        this.validatorDir = (0, node_path_1.resolve)(_dirname, "..", "..", "validator");
        this.defaultRegistryPort = 8545;
        if (typeof validatorDir === "string") {
            this.validatorDir = validatorDir;
        }
        if (typeof registryPort === "number") {
            // Port sanitization happens in the parent Local Tableland process
            this.registryPort = registryPort;
        }
        else {
            this.registryPort = this.defaultRegistryPort;
        }
    }
    start(registryAddress) {
        const binPath = (0, validator_1.getBinPath)();
        if (binPath == null) {
            throw new Error(`cannot start with: arch ${process.arch}, platform ${process.platform}`);
        }
        // Get the path to the directory holding the validator config we want to use.
        // Windows looks like C:\Users\tester\Workspaces\test-loc\node_modules\@tableland\local\validator
        // unix looks like      /Users/tester/Workspaces/test-loc/node_modules/@tableland/local/validator
        // We have to convert the windows path to a valid URI so that the validator can
        // use it to create a sqlite connection string, basically make windows act like unix.
        let validatorUri = "";
        if ((0, util_js_1.isWindows)()) {
            // remove the C:
            if (this.validatorDir.indexOf("C:") === 0) {
                validatorUri = this.validatorDir.slice(2);
            }
            validatorUri = validatorUri.replace("\\", "/");
        }
        else {
            validatorUri = this.validatorDir;
        }
        // get the validator config file
        const configFilePath = (0, node_path_1.join)(this.validatorDir, "config.json");
        const configFileStr = (0, node_fs_1.readFileSync)(configFilePath).toString();
        const validatorConfig = JSON.parse(configFileStr);
        // save the validator config state
        ORIGINAL_VALIDATOR_CONFIG = configFileStr;
        // make sure the value in the config file matches the port we are using
        // if not, update the validator config file with a new `EthEndpoint` port
        if (validatorConfig.Chains[0].Registry.EthEndpoint !==
            `ws://localhost:${this.registryPort}`) {
            validatorConfig.Chains[0].Registry.EthEndpoint = `ws://localhost:${this.registryPort}`;
            (0, node_fs_1.writeFileSync)(configFilePath, JSON.stringify(validatorConfig, null, 2));
        }
        // start the validator
        this.process = (0, cross_spawn_1.default)(binPath, ["--dir", validatorUri], {
            // we can't run in windows if we use detached mode
            detached: !(0, util_js_1.isWindows)(),
        });
    }
    shutdown() {
        if (this.process == null)
            throw new Error("Cannot find validator process");
        // If this Class is imported and run by a test runner then the ChildProcess instances are
        // sub-processes of a ChildProcess instance which means in order to kill them in a way that
        // enables graceful shut down they have to run in detached mode and be killed by the pid
        try {
            // @ts-expect-error pid is possibly undefined, which is fine
            process.kill(-this.process.pid);
        }
        catch (err) {
            // It's possible that a pid will exist, but the process is terminated
            // e.g., try running two Local Tableland instances at the same time. If
            // this happens, `cleanup` never gets called (e.g., files not reset).
            if (err.code === "ESRCH") {
                throw new Error(`validator process already killed`);
            }
            else {
                throw err;
            }
        }
    }
    // fully nuke the database and reset the config file
    cleanup() {
        shelljs_1.default.rm("-rf", (0, node_path_1.resolve)(this.validatorDir, "backups"));
        const dbFiles = [
            (0, node_path_1.resolve)(this.validatorDir, "database.db"),
            (0, node_path_1.resolve)(this.validatorDir, "metrics.db"),
        ];
        for (const filepath of dbFiles) {
            shelljs_1.default.rm("-f", filepath);
        }
        // reset the Validator config file in case it was modified with a custom
        // Registry hardhat port
        if (ORIGINAL_VALIDATOR_CONFIG != null) {
            const configFilePath = (0, node_path_1.join)(this.validatorDir, "config.json");
            (0, node_fs_1.writeFileSync)(configFilePath, ORIGINAL_VALIDATOR_CONFIG);
        }
    }
}
exports.ValidatorPkg = ValidatorPkg;
class ValidatorDev {
    constructor(validatorDir, registryPort) {
        this.defaultRegistryPort = 8545;
        if (validatorDir == null)
            throw new Error("must supply path to validator");
        this.validatorDir = validatorDir;
        if (typeof registryPort === "number") {
            // Port sanitization happens in the parent Local Tableland process
            this.registryPort = registryPort;
        }
        else {
            this.registryPort = this.defaultRegistryPort;
        }
    }
    start(registryAddress) {
        if (typeof registryAddress !== "string") {
            throw new Error("must provide registry address");
        }
        // Add the registry address to the Validator config
        // TODO: when https://github.com/tablelandnetwork/go-tableland/issues/317 is
        //       resolved we may be able to refactor a lot of this
        const configFilePath = (0, node_path_1.join)(this.validatorDir, "docker", "local", "api", "config.json");
        const configFileStr = (0, node_fs_1.readFileSync)(configFilePath).toString();
        const validatorConfig = JSON.parse(configFileStr);
        // save the validator config state before this script modifies it
        ORIGINAL_VALIDATOR_CONFIG = configFileStr;
        // make sure the value in the config file matches the port we are using
        // if not, update the validator config file with a new `EthEndpoint` port
        if (validatorConfig.Chains[0].Registry.EthEndpoint !==
            `ws://localhost:${this.registryPort}`) {
            validatorConfig.Chains[0].Registry.EthEndpoint = `ws://localhost:${this.registryPort}`;
        }
        validatorConfig.Chains[0].Registry.ContractAddress = registryAddress;
        (0, node_fs_1.writeFileSync)(configFilePath, JSON.stringify(validatorConfig, null, 2));
        // start the validator
        this.process = (0, cross_spawn_1.default)("make", ["local-up"], {
            // we can't run in windows if we use detached mode
            detached: !(0, util_js_1.isWindows)(),
            cwd: (0, node_path_1.join)(this.validatorDir, "docker"),
        });
    }
    shutdown() {
        // The validator uses make to shutdown when run via docker
        spawnSync("make", ["local-down"], {
            cwd: (0, node_path_1.join)(this.validatorDir, "docker"),
        });
        // If this Class is imported and run by a test runner then the ChildProcess instances are
        // sub-processes of a ChildProcess instance which means in order to kill them in a way that
        // enables graceful shut down they have to run in detached mode and be killed by the pid
        try {
            // @ts-expect-error pid is possibly undefined, which is fine
            process.kill(-this.process.pid);
        }
        catch (err) {
            // It's possible that a pid will exist, but the process is terminated
            // e.g., try running two Local Tableland instances at the same time. If
            // this happens, `cleanup` never gets called (e.g., files not reset).
            if (err.code === "ESRCH") {
                throw new Error(`validator process already killed`);
            }
            else {
                throw err;
            }
        }
    }
    cleanup() {
        (0, util_js_1.logSync)(spawnSync("docker", ["container", "prune", "-f"]));
        spawnSync("docker", ["image", "rm", "docker-api", "-f"]);
        spawnSync("docker", ["volume", "prune", "-f"]);
        const dbFiles = [
            (0, node_path_1.join)(this.validatorDir, "docker", "local", "api", "database.db"),
            (0, node_path_1.join)(this.validatorDir, "docker", "local", "api", "database.db-shm"),
            (0, node_path_1.join)(this.validatorDir, "docker", "local", "api", "database.db-wal"),
        ];
        for (const filepath of dbFiles) {
            spawnSync("rm", ["-f", filepath]);
        }
        // reset the Validator config file that is modified on startup and/or custom
        // Registry port configurations
        if (ORIGINAL_VALIDATOR_CONFIG != null) {
            const configFilePath = (0, node_path_1.join)(this.validatorDir, "docker", "local", "api", "config.json");
            (0, node_fs_1.writeFileSync)(configFilePath, ORIGINAL_VALIDATOR_CONFIG);
        }
    }
}
exports.ValidatorDev = ValidatorDev;
//# sourceMappingURL=validators.js.map