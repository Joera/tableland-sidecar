"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.prepareCreateOne = void 0;
const index_js_1 = require("../helpers/index.js");
const ethers_js_1 = require("../helpers/ethers.js");
const parser_js_1 = require("../helpers/parser.js");
const contract_js_1 = require("./contract.js");
// Match _anything_ between create table and schema portion of create statement (statement must be a single line)
const firstSearch = /(?<create>^CREATE\s+TABLE\s+)(?<name>\S+)(?<schema>\s*\(.*\)[;]?$)/i;
const escapeChars = /"|'|`|\]|\[/;
async function prepareCreateOne({ statement, chainId, first, }) {
    if (first == null) {
        const normalized = await (0, index_js_1.normalize)(statement);
        first = normalized.tables[0];
    }
    const { prefix, name: tableName } = await (0, parser_js_1.validateTableName)(`${first}_${chainId}`, true);
    const stmt = statement
        .replace(/\n/g, "")
        .replace(/\r/g, "")
        .replace(firstSearch, function (_, create, name, schema) {
        // If this name has any escape chars, escape the whole thing.
        const newName = escapeChars.test(name) ? `[${tableName}]` : tableName;
        return `${create.trim()} ${newName.trim()} ${schema.trim()}`;
    });
    return { statement: stmt, chainId, prefix };
}
exports.prepareCreateOne = prepareCreateOne;
async function create(config, params) {
    if (isCreateOne(params)) {
        return await _createOne(config, params);
    }
    return await _createMany(config, params);
}
exports.create = create;
async function _createOne({ signer }, { statement, chainId }) {
    const owner = await signer.getAddress();
    const { contract, overrides } = await (0, contract_js_1.getContractAndOverrides)(signer, chainId);
    if ((0, ethers_js_1.isPolygon)(chainId)) {
        const gasLimit = await contract.estimateGas["create(address,string)"](owner, statement, overrides);
        overrides.gasLimit = Math.floor(gasLimit.toNumber() * 1.2);
    }
    return await contract["create(address,string)"](owner, statement, overrides);
}
async function _createMany({ signer }, { statements, chainId }) {
    const owner = await signer.getAddress();
    const { contract, overrides } = await (0, contract_js_1.getContractAndOverrides)(signer, chainId);
    if ((0, ethers_js_1.isPolygon)(chainId)) {
        const gasLimit = await contract.estimateGas["create(address,string[])"](owner, statements, overrides);
        overrides.gasLimit = Math.floor(gasLimit.toNumber() * 1.2);
    }
    return await contract["create(address,string[])"](owner, statements, overrides);
}
const isCreateOne = function (params) {
    return params.statement !== undefined;
};
//# sourceMappingURL=create.js.map