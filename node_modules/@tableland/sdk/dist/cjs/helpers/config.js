"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeNameMapping = exports.readNameMapping = exports.prepReadConfig = exports.extractChainId = exports.extractSigner = exports.extractBaseUrl = exports.checkWait = void 0;
const chains_js_1 = require("./chains.js");
const ethers_js_1 = require("./ethers.js");
const utils_js_1 = require("./utils.js");
async function checkWait(config, receipt, controller) {
    if (config.autoWait ?? false) {
        const waited = await receipt.wait(controller);
        return { ...receipt, ...waited };
    }
    return receipt;
}
exports.checkWait = checkWait;
async function extractBaseUrl(conn = {}, chainNameOrId) {
    if (conn.baseUrl == null) {
        if (conn.signer == null) {
            if (chainNameOrId == null) {
                throw new Error("missing connection information: baseUrl, signer, or chainId required");
            }
            return (0, chains_js_1.getBaseUrl)(chainNameOrId);
        }
        const chainId = await conn.signer.getChainId();
        return (0, chains_js_1.getBaseUrl)(chainId);
    }
    return conn.baseUrl;
}
exports.extractBaseUrl = extractBaseUrl;
async function extractSigner(conn = {}, external) {
    if (conn.signer == null) {
        return await (0, ethers_js_1.getSigner)(external);
    }
    return conn.signer;
}
exports.extractSigner = extractSigner;
async function extractChainId(conn = {}) {
    const signer = await extractSigner(conn);
    const chainId = await signer.getChainId();
    if (chainId === 0 || isNaN(chainId) || chainId == null) {
        /* c8 ignore next 4 */
        throw new Error("cannot find chainId: is your signer connected to a network?");
    }
    return chainId;
}
exports.extractChainId = extractChainId;
function prepReadConfig(config) {
    const conf = {};
    if (config.apiKey) {
        conf.init = {
            headers: {
                "Api-Key": config.apiKey,
            },
        };
    }
    return { ...config, ...conf };
}
exports.prepReadConfig = prepReadConfig;
/**
 * Read the {@link NameMapping} from an {@link AliasesNameMap}, which can
 * support either synchronous or asynchronous `read()` execution. It will wrap a
 * synchronous name mapping result, or wrap an unwrapped name mapping if
 * asynchronous.
 * @param aliases An `AliasesNameMap` object.
 * @returns A promise containing a `NameMapping` object.
 */
async function readNameMapping(aliases) {
    const nameMap = aliases.read();
    return (0, utils_js_1.isPromise)(nameMap) ? await nameMap : nameMap;
}
exports.readNameMapping = readNameMapping;
/**
 * Write table aliases with an {@link AliasesNameMap} and a provided
 * {@link NameMapping}, which can support either synchronous or asynchronous
 * `write()` execution. It will wrap a synchronous result, or wrap an unwrapped
 * result if asynchronous.
 * @param aliases An `AliasesNameMap` object to write to.
 * @param nameMap A `NameMapping` object to write to the `AliasesNameMap`.
 * @returns A promise containing `void` upon write completion.
 */
async function writeNameMapping(aliases, nameMap) {
    const result = aliases.write(nameMap);
    return (0, utils_js_1.isPromise)(result) ? await result : result;
}
exports.writeNameMapping = writeNameMapping;
//# sourceMappingURL=config.js.map