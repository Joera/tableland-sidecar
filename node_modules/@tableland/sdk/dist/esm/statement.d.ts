import { type ValuesType, type Parameters, type BaseType } from "./helpers/binding.js";
import { type AutoWaitConfig, type Config, type PollingController } from "./helpers/index.js";
import { type Result } from "./registry/utils.js";
import { type ValueOf } from "./validator/query.js";
export { type ValuesType, type Parameters, type ValueOf, type BaseType };
/**
 * Options for `all`, `first`, `run`, and `raw` methods.
 * @property controller An optional {@link PollingController} used to control receipt polling behavior.
 */
export interface Options {
    controller?: PollingController;
}
/**
 * Statement defines a single SQL statement.
 * Both static and prepared statements are supported. In the current
 * implementation, the prepared statements are prepared locally, and
 * executed remotely (on-chain).
 * Mutating transactions such as INSERTs, DELETEs, and UPDATEs produce
 * a two-phase transaction. Firstly, the transaction is sent to the
 * registry contract, and awaited. The returned `txn` information also
 * contains a `wait` method than can be used to await finalization on
 * the Tableland network. This method will also throw an exception if
 * any runtime errors occur.
 */
export declare class Statement<S = unknown> {
    #private;
    private readonly config;
    private readonly sql;
    private readonly parameters?;
    constructor(config: Config & Partial<AutoWaitConfig>, sql: string, parameters?: Parameters);
    /**
     * Bind a set of values to the parameters of the prepared statement.
     * We follow the SQLite convention for prepared statements parameter binding.
     * We support Ordered (?NNNN), Anonymous (?), and Named (@name, :name, $name) parameters.
     * @param values A variadic list of values to bind. May include base types, and objects.
     * @returns A new bound Statement.
     */
    bind<T = S>(...values: ValuesType[]): Statement<T>;
    /**
     * Resolve a bound statement to a SQL string.
     * @returns A valid SQL string.
     */
    toString(): string;
    /**
     * Export a Statement's sql string and parameters.
     * @returns
     */
    toObject(): {
        sql: string;
        parameters?: Parameters;
    };
    /**
     * Executes a query and returns all rows and metadata.
     * @param opts An optional object used to control behavior, see {@link Options}
     */
    all<T = Record<string, S>>(opts?: Options): Promise<Result<T>>;
    /**
     * Executes a query and returns the first row of the results.
     * This does not return metadata like the other methods.
     * Instead it returns the object directly. If the query returns no
     * rows, then first() will return null.
     * @param colName If provided, filter results to the provided column.
     * @param opts An optional object used to control behavior, see {@link Options}
     */
    first<T = Record<string, S>>(opts?: Options): Promise<T | null>;
    first<T = S, K extends keyof T & string = keyof T & string>(colName: undefined, opts?: Options): Promise<T>;
    first<T = S, K extends keyof T & string = keyof T & string>(colName: K, opts?: Options): Promise<T[K] | null>;
    /**
     * Runs the query/queries, but returns no results. Instead, run()
     * returns the metrics only. Useful for write operations like
     * UPDATE, DELETE or INSERT.
     * @param opts An optional object used to control behavior, see {@link Options}
     * @returns A results object with metadata only (results are null or an empty array).
     */
    run<T = Record<string, S>>(opts?: Options): Promise<Result<T>>;
    /**
     * Same as stmt.all(), but returns an array of rows instead of objects.
     * @param opts An optional object used to control behavior, see {@link Options}
     * @returns An array of raw query results.
     */
    raw<T = S>(opts?: Options): Promise<Array<ValueOf<T>>>;
}
//# sourceMappingURL=statement.d.ts.map