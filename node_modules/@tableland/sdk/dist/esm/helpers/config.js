import { getBaseUrl } from "./chains.js";
import { getSigner } from "./ethers.js";
import { isPromise } from "./utils.js";
export async function checkWait(config, receipt, controller) {
    if (config.autoWait ?? false) {
        const waited = await receipt.wait(controller);
        return { ...receipt, ...waited };
    }
    return receipt;
}
export async function extractBaseUrl(conn = {}, chainNameOrId) {
    if (conn.baseUrl == null) {
        if (conn.signer == null) {
            if (chainNameOrId == null) {
                throw new Error("missing connection information: baseUrl, signer, or chainId required");
            }
            return getBaseUrl(chainNameOrId);
        }
        const chainId = await conn.signer.getChainId();
        return getBaseUrl(chainId);
    }
    return conn.baseUrl;
}
export async function extractSigner(conn = {}, external) {
    if (conn.signer == null) {
        return await getSigner(external);
    }
    return conn.signer;
}
export async function extractChainId(conn = {}) {
    const signer = await extractSigner(conn);
    const chainId = await signer.getChainId();
    if (chainId === 0 || isNaN(chainId) || chainId == null) {
        /* c8 ignore next 4 */
        throw new Error("cannot find chainId: is your signer connected to a network?");
    }
    return chainId;
}
export function prepReadConfig(config) {
    const conf = {};
    if (config.apiKey) {
        conf.init = {
            headers: {
                "Api-Key": config.apiKey,
            },
        };
    }
    return { ...config, ...conf };
}
/**
 * Read the {@link NameMapping} from an {@link AliasesNameMap}, which can
 * support either synchronous or asynchronous `read()` execution. It will wrap a
 * synchronous name mapping result, or wrap an unwrapped name mapping if
 * asynchronous.
 * @param aliases An `AliasesNameMap` object.
 * @returns A promise containing a `NameMapping` object.
 */
export async function readNameMapping(aliases) {
    const nameMap = aliases.read();
    return isPromise(nameMap) ? await nameMap : nameMap;
}
/**
 * Write table aliases with an {@link AliasesNameMap} and a provided
 * {@link NameMapping}, which can support either synchronous or asynchronous
 * `write()` execution. It will wrap a synchronous result, or wrap an unwrapped
 * result if asynchronous.
 * @param aliases An `AliasesNameMap` object to write to.
 * @param nameMap A `NameMapping` object to write to the `AliasesNameMap`.
 * @returns A promise containing `void` upon write completion.
 */
export async function writeNameMapping(aliases, nameMap) {
    const result = aliases.write(nameMap);
    return isPromise(result) ? await result : result;
}
//# sourceMappingURL=config.js.map